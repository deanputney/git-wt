#!/bin/bash
#
# git-crypt post-worktree-add hook
#
# This hook works around the known incompatibility between git-crypt and git worktree.
# Install this to .git/hooks/post-worktree-add to enable git-crypt support.
#
# INSTALLATION:
#   cp examples/hooks/git-crypt-pre-worktree-add .git/hooks/pre-worktree-add
#   cp examples/hooks/git-crypt-post-worktree-add .git/hooks/post-worktree-add
#   chmod +x .git/hooks/pre-worktree-add .git/hooks/post-worktree-add

# Check if git-crypt is in use
if ! git config --get filter.git-crypt.smudge >/dev/null 2>&1; then
  # git-crypt not configured, nothing to do
  exit 0
fi

# Use GIT_WORKTREE_PATH environment variable set by git-wt
if [ -z "$GIT_WORKTREE_PATH" ]; then
  echo "git-crypt post-worktree-add: GIT_WORKTREE_PATH not set" >&2
  exit 1
fi

# Restore git-crypt filter settings in the main repo from saved environment variables
if [ -n "$GIT_WT_SAVED_SMUDGE" ]; then
  git config filter.git-crypt.smudge "$GIT_WT_SAVED_SMUDGE"
else
  git config --unset filter.git-crypt.smudge || true
fi

if [ -n "$GIT_WT_SAVED_CLEAN" ]; then
  git config filter.git-crypt.clean "$GIT_WT_SAVED_CLEAN"
else
  git config --unset filter.git-crypt.clean || true
fi

if [ -n "$GIT_WT_SAVED_REQUIRED" ]; then
  git config filter.git-crypt.required "$GIT_WT_SAVED_REQUIRED"
else
  git config --unset filter.git-crypt.required || true
fi

# Now handle the worktree: configure filters, unlock git-crypt, then decrypt files
# (Files are already in encrypted state from initial checkout with cat filters)

# Find an existing worktree with .git-crypt to copy from
# Try each worktree until we find one with .git-crypt
while IFS= read -r wt_path; do
  if [ -d "$wt_path/.git-crypt" ]; then
    cp -r "$wt_path/.git-crypt" "$GIT_WORKTREE_PATH/" 2>/dev/null || true
    break
  fi
done < <(git worktree list --porcelain | grep "^worktree " | cut -d' ' -f2)

# Temporarily disable filters in the worktree to avoid circular dependency during unlock
git -C "$GIT_WORKTREE_PATH" config filter.git-crypt.smudge "cat"
git -C "$GIT_WORKTREE_PATH" config filter.git-crypt.clean "cat"
git -C "$GIT_WORKTREE_PATH" config --unset filter.git-crypt.required || true

# Unlock git-crypt in the new worktree
if ! git -C "$GIT_WORKTREE_PATH" crypt unlock 2>/dev/null; then
  # Restore filters even if unlock failed (using saved environment variables)
  if [ -n "$GIT_WT_SAVED_SMUDGE" ]; then
    git -C "$GIT_WORKTREE_PATH" config filter.git-crypt.smudge "$GIT_WT_SAVED_SMUDGE"
  fi
  if [ -n "$GIT_WT_SAVED_CLEAN" ]; then
    git -C "$GIT_WORKTREE_PATH" config filter.git-crypt.clean "$GIT_WT_SAVED_CLEAN"
  fi
  if [ -n "$GIT_WT_SAVED_REQUIRED" ]; then
    git -C "$GIT_WORKTREE_PATH" config filter.git-crypt.required "$GIT_WT_SAVED_REQUIRED"
  fi

  echo "git-crypt post-worktree-add: Warning: Could not unlock git-crypt in $GIT_WORKTREE_PATH" >&2
  echo "You may need to run 'git crypt unlock' manually in the worktree" >&2
  # Don't fail - the worktree was created successfully
  exit 0
fi

# Restore proper filter settings (using saved environment variables)
if [ -n "$GIT_WT_SAVED_SMUDGE" ]; then
  git -C "$GIT_WORKTREE_PATH" config filter.git-crypt.smudge "$GIT_WT_SAVED_SMUDGE"
fi
if [ -n "$GIT_WT_SAVED_CLEAN" ]; then
  git -C "$GIT_WORKTREE_PATH" config filter.git-crypt.clean "$GIT_WT_SAVED_CLEAN"
fi
if [ -n "$GIT_WT_SAVED_REQUIRED" ]; then
  git -C "$GIT_WORKTREE_PATH" config filter.git-crypt.required "$GIT_WT_SAVED_REQUIRED"
fi

# Final checkout to decrypt all files
git -C "$GIT_WORKTREE_PATH" reset --hard HEAD --quiet

exit 0
