#!/bin/bash

# Helper function to find the common git directory where hooks are stored
find_git_common_dir() {
  # In worktrees, --git-common-dir gives the shared .git directory
  # In normal repos, it returns the same as --git-dir
  local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
  echo "$git_common_dir"
}

# Helper function to run a hook if it exists
run_hook() {
  local hook_name="$1"
  shift
  local git_common_dir=$(find_git_common_dir)

  if [ -z "$git_common_dir" ]; then
    return 0
  fi

  local hook_path="$git_common_dir/hooks/$hook_name"

  if [ -x "$hook_path" ]; then
    "$hook_path" "$@"
    return $?
  fi

  return 0
}

# Helper function to show help
show_help() {
  cat << 'EOF'
git-wt - An opinionated git alias for working with worktrees

USAGE:
  git wt <command> [options]

COMMANDS:
  clone <url> [folder]       Clone a repository with bare .git and worktree structure
  init                       Convert existing repo to worktree structure
  add <path> [branch]        Create a new worktree (alias: a)
  remove <path>              Remove a worktree (alias: rm)
  list                       List all worktrees (alias: ls)
  install-hooks <type>       Install hook examples (e.g., git-crypt)
  setup [--config-only]      Install git-wt and configure git alias

      Note: If you installed via Homebrew, you don't need to run this.
            Homebrew installation already configures everything.

      Options:
        --config-only    Only configure git alias (skip installation)

EXAMPLES:
  git wt clone https://github.com/user/repo
    Clone a repository with clean worktree structure

  git wt init
    Convert your existing repository to use worktrees

  git wt add feature-branch
    Create a new worktree for 'feature-branch'

  git wt install-hooks hello-world
    Install example hooks to see how the hook system works

  git wt install-hooks git-crypt
    Install git-crypt hooks for encrypted repositories

  git wt list
    Show all worktrees in the repository

  git wt setup
    Install git-wt and configure git alias (for manual installation)

  git wt setup --config-only
    Only configure git alias (if git-wt is already installed)

ALIASES:
  a   -> add
  rm  -> remove
  ls  -> list
  cl  -> clone
  i   -> init

MORE INFORMATION:
  Documentation: https://github.com/deanputney/git-wt
  Hooks: See HOOKS.md for custom hook documentation

EOF

  # Interactive prompt to show git worktree help
  echo ""
  read -p "Press Enter to view 'git worktree --help' or Ctrl+C to exit... " -r
  echo ""
  git worktree --help
}

# Helper function to show available hooks
show_available_hooks() {
  echo "Available hooks for installation:"
  echo ""
  echo "  hello-world"
  echo "    Simple example hooks that print messages (learning/testing)"
  echo "    Files: pre-worktree-add, post-worktree-add"
  echo ""
  echo "  git-crypt"
  echo "    Handles encrypted files in worktrees (git-crypt integration)"
  echo "    Files: pre-worktree-add, post-worktree-add"
  echo ""
  echo "Usage:"
  echo "  git wt install-hooks <hook-type>"
  echo ""
  echo "Examples:"
  echo "  git wt install-hooks hello-world"
  echo "  git wt install-hooks git-crypt"
}

# Helper function to install hooks
install_hooks() {
  local hook_type="$1"

  # Validate we're in a git repository
  local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
  if [ -z "$git_common_dir" ]; then
    echo "Error: Not in a git repository. Run this command from inside your repository." >&2
    exit 1
  fi

  local hooks_dir="$git_common_dir/hooks"

  # Find script directory to locate example hooks
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local examples_dir="$script_dir/examples/hooks"

  # Validate hook type and get hook file paths
  local pre_hook=""
  local post_hook=""

  case "$hook_type" in
    hello-world)
      pre_hook="$examples_dir/hello-world-pre-worktree-add"
      post_hook="$examples_dir/hello-world-post-worktree-add"
      ;;
    git-crypt)
      pre_hook="$examples_dir/git-crypt-pre-worktree-add"
      post_hook="$examples_dir/git-crypt-post-worktree-add"
      ;;
    *)
      echo "Error: Unknown hook type '$hook_type'" >&2
      echo "Run 'git wt install-hooks' to see available hooks." >&2
      exit 1
      ;;
  esac

  # Validate example hooks exist
  if [ ! -f "$pre_hook" ] || [ ! -f "$post_hook" ]; then
    echo "Error: Hook examples not found at $examples_dir" >&2
    echo "Ensure git-wt is properly installed with example hooks." >&2
    exit 1
  fi

  # Create hooks directory if it doesn't exist
  mkdir -p "$hooks_dir"

  # Check for existing hooks
  local target_pre="$hooks_dir/pre-worktree-add"
  local target_post="$hooks_dir/post-worktree-add"

  if [ -f "$target_pre" ] || [ -f "$target_post" ]; then
    echo "Warning: Hooks already exist:"
    [ -f "$target_pre" ] && echo "  $target_pre"
    [ -f "$target_post" ] && echo "  $target_post"
    echo ""
    read -p "Overwrite existing hooks? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo "Installation cancelled."
      exit 0
    fi
  fi

  # Copy and chmod hooks
  if ! cp "$pre_hook" "$target_pre"; then
    echo "Error: Failed to copy pre-worktree-add hook. Check permissions for $hooks_dir" >&2
    exit 1
  fi

  if ! cp "$post_hook" "$target_post"; then
    echo "Error: Failed to copy post-worktree-add hook. Check permissions for $hooks_dir" >&2
    exit 1
  fi

  chmod +x "$target_pre" "$target_post"

  # Success message
  echo "Successfully installed $hook_type hooks!"
  echo ""
  echo "Installed to:"
  echo "  $target_pre"
  echo "  $target_post"
  echo ""
  echo "The hooks will now run automatically when you use 'git wt add'."
}

# Helper function to set up git alias configuration
setup_git_config() {
  # Check if alias is already configured
  if git config --global alias.wt >/dev/null 2>&1; then
    local current_alias=$(git config --global alias.wt)
    if [ "$current_alias" = "!git-wt" ]; then
      echo "✓ Git alias already configured: git config --global alias.wt '!git-wt'"
      return 0
    else
      echo "Warning: git alias 'wt' is already set to: $current_alias"
      read -p "Do you want to overwrite it with '!git-wt'? (y/N) " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Skipped git alias configuration."
        return 0
      fi
    fi
  fi

  # Set up git alias
  git config --global alias.wt '!git-wt'
  echo "✓ Git alias configured: git config --global alias.wt '!git-wt'"
}

init_new_repo() {
  echo "Initializing new git-wt repository..."
  echo ""

  # Default branch name
  primary_branch="main"

  # Collect existing files (if any)
  has_files=false
  if [ "$(ls -A . 2>/dev/null)" ]; then
    has_files=true
    echo "Found existing files - they will be added to the initial commit"
    echo ""
  fi

  # Create temporary directory for existing files
  temp_work=""
  if [ "$has_files" = true ]; then
    temp_work=".git-wt-temp-work-$$"
    mkdir "$temp_work"
    find . -maxdepth 1 ! -name . ! -name .. ! -name "$temp_work" \
      -exec mv {} "$temp_work/" \; 2>/dev/null || true
  fi

  # Initialize bare repository
  echo "Creating bare repository..."
  git init --bare .git

  # Configure git in the bare repo
  git -C .git config --bool core.bare true
  git -C .git config user.name "git-wt"
  git -C .git config user.email "git-wt@localhost"

  # Set HEAD to main branch
  echo "ref: refs/heads/$primary_branch" > .git/HEAD

  # Create initial commit on main branch
  # We need a commit to exist before creating worktrees
  export GIT_DIR=.git

  # Always need a work tree for commits (even --allow-empty)
  if [ "$has_files" = false ]; then
    temp_work=".git-wt-temp-work-$$"
    mkdir "$temp_work"
  fi

  export GIT_WORK_TREE="$temp_work"

  if [ "$has_files" = true ]; then
    # Add all existing files
    git add -A
    git commit -m "Initial commit"
  else
    # Create empty initial commit
    git commit --allow-empty -m "Initial commit"
  fi

  unset GIT_WORK_TREE
  unset GIT_DIR

  # Create worktree for main branch
  echo "Creating worktree for '$primary_branch' branch..."
  if [ "$has_files" = true ]; then
    # Move preserved files to main/ worktree
    # Create parent directories if branch name contains slashes (e.g., feature/foo)
    mkdir -p "$(dirname "$primary_branch")"
    mv "$temp_work" "$primary_branch"

    # Register as worktree manually
    repo_root=$(pwd)
    # Convert slashes to dashes for worktree metadata directory name
    # (git encodes slashes when creating worktree metadata)
    worktree_name=$(echo "$primary_branch" | tr '/' '-')
    mkdir -p .git/worktrees/"$worktree_name"
    echo "gitdir: $repo_root/.git/worktrees/$worktree_name" > "$primary_branch/.git"
    echo "$repo_root/$primary_branch" > .git/worktrees/"$worktree_name"/gitdir
    echo "ref: refs/heads/$primary_branch" > .git/worktrees/"$worktree_name"/HEAD
    touch .git/worktrees/"$worktree_name"/commondir
    echo "../.." > .git/worktrees/"$worktree_name"/commondir

    # Reset the worktree to sync with the commit
    cd "$primary_branch"
    git reset --hard HEAD >/dev/null 2>&1
    cd ..
  else
    # Clean up temp work dir and create worktree normally
    rm -rf "$temp_work"
    git worktree add "$primary_branch" "$primary_branch" 2>&1 | grep -v "^Preparing worktree" || true
  fi

  # Success message
  echo ""
  echo "Successfully initialized git-wt repository!"
  echo ""
  echo "Repository structure:"
  echo "  .git/                    (bare repository)"
  echo "  $primary_branch/         (worktree - primary branch)"
  echo ""
  if [ "$has_files" = true ]; then
    echo "Existing files have been committed to the '$primary_branch' branch"
    echo ""
  fi
  echo "Worktree list:"
  git worktree list
}

case "$1" in
  a|add)
    shift

    # Run pre-worktree-add hook with the arguments that will be passed to git worktree add
    run_hook "pre-worktree-add" "$@"
    hook_status=$?

    if [ $hook_status -ne 0 ]; then
      echo "git-wt: pre-worktree-add hook failed with exit code $hook_status" >&2
      exit $hook_status
    fi

    # Extract the worktree path (first argument)
    worktree_path="$1"

    # Create the worktree
    git worktree add "$@"
    add_status=$?

    if [ $add_status -ne 0 ]; then
      echo "git-wt: git worktree add failed with exit code $add_status" >&2
      exit $add_status
    fi

    # Run post-worktree-add hook with the worktree path and all original arguments
    run_hook "post-worktree-add" "$worktree_path" "$@"
    hook_status=$?

    if [ $hook_status -ne 0 ]; then
      echo "git-wt: post-worktree-add hook failed with exit code $hook_status" >&2
      echo "git-wt: worktree was created but post-processing failed" >&2
      exit $hook_status
    fi
    ;;

  rm|remove)
    shift
    git worktree remove "$@"
    ;;

  ls|list)
    shift
    git worktree list
    ;;

  cl|clone)
    shift
    repo_url="$1"
    folder_name="${2:-$(basename "$repo_url" .git)}"

    if [ -z "$repo_url" ]; then
      echo "Usage: git-wt clone <repository-url> [folder-name]"
      exit 1
    fi

    # Create the folder and clone bare
    mkdir -p "$folder_name"
    git clone --bare "$repo_url" "$folder_name/.git"

    # Set up fetch refspec for remote tracking
    git -C "$folder_name/.git" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

    # Determine the primary branch from HEAD
    primary_branch=$(git -C "$folder_name/.git" symbolic-ref --short HEAD 2>/dev/null)

    # Fallback to main or master
    if [ -z "$primary_branch" ]; then
      if git -C "$folder_name/.git" rev-parse --verify refs/heads/main >/dev/null 2>&1; then
        primary_branch="main"
      elif git -C "$folder_name/.git" rev-parse --verify refs/heads/master >/dev/null 2>&1; then
        primary_branch="master"
      else
        echo "Error: Could not determine primary branch"
        exit 1
      fi
    fi

    # Add worktree for primary branch
    git -C "$folder_name/.git" worktree add "../$primary_branch" "$primary_branch"

    echo "Cloned $repo_url into $folder_name/"
    echo "Primary branch '$primary_branch' checked out at $folder_name/$primary_branch/"
    ;;

  i|init)
    shift

    # Pre-flight checks

    # 1. Detect if we're in a git repository
    is_existing_repo=false
    if git rev-parse --git-dir >/dev/null 2>&1; then
      is_existing_repo=true
    fi

    # Branch based on repository status
    if [ "$is_existing_repo" = false ]; then
      # NEW LOGIC: Initialize new repository from scratch
      init_new_repo
      exit 0
    fi

    # EXISTING LOGIC: Convert existing repository to worktree structure

    # 2. Check if already bare
    if [ "$(git rev-parse --is-bare-repository)" = "true" ]; then
      echo "Error: Repository is already bare"
      exit 1
    fi

    # 3. Check if we're inside a worktree structure
    git_dir=$(git rev-parse --git-dir)
    if echo "$git_dir" | grep -q "\.git/worktrees"; then
      echo "Error: Already in a worktree-based repository structure"
      echo "This command only works on standard git repositories"
      exit 1
    fi

    # 4. Check for existing worktrees
    worktree_count=$(git worktree list | wc -l | tr -d ' ')
    if [ "$worktree_count" -gt 1 ]; then
      echo "Error: Repository already has worktrees"
      echo "This command only works on repositories without existing worktrees"
      git worktree list
      exit 1
    fi

    # 5. Get current branch (or detect detached HEAD)
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [ -z "$current_branch" ]; then
      echo "Error: Repository is in detached HEAD state"
      echo "Please checkout a branch before running git wt init"
      exit 1
    fi

    # 6. Check for uncommitted changes or untracked files
    has_changes=false
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
      has_changes=true
    fi
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
      has_changes=true
    fi

    if [ "$has_changes" = true ]; then
      echo "Warning: You have uncommitted changes or untracked files"
      echo ""
      git status --short
      echo ""
      echo "These will be preserved in the '$current_branch' worktree after conversion"
      echo ""
      read -p "Continue with conversion? (y/N): " confirm
      if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Aborted"
        exit 0
      fi
    fi

    # 7. Check for stashes (informational)
    stash_count=$(git stash list 2>/dev/null | wc -l | tr -d ' ')
    if [ "$stash_count" -gt 0 ]; then
      echo "Note: Found $stash_count stash(es). These will be preserved."
    fi

    # Get repository root
    repo_root=$(git rev-parse --show-toplevel)
    cd "$repo_root" || exit 1

    # Set up error handling
    temp_bare=""
    temp_work=""
    temp_index=""

    cleanup_on_error() {
      echo ""
      echo "Error occurred during conversion!"
      if [ -n "$temp_work" ] && [ -d "$temp_work" ]; then
        echo "Your files are preserved in: $temp_work"
        echo "Your .git directory has been modified. To recover:"
        echo "  1. Restore from backup if you have one"
        echo "  2. Or manually move files back from $temp_work"
      fi
      if [ -n "$temp_bare" ] && [ -d "$temp_bare" ]; then
        rm -rf "$temp_bare"
      fi
      if [ -n "$temp_index" ] && [ -f "$temp_index" ]; then
        rm -f "$temp_index"
      fi
      exit 1
    }

    trap cleanup_on_error ERR

    echo "Converting repository to worktree structure..."
    echo ""

    # Create temporary bare clone (preserves all refs, stashes, config)
    temp_bare=".git-wt-temp-bare-$$"
    echo "Creating bare repository..."
    git clone --bare . "$temp_bare" 2>&1 | grep -v "^Cloning into" || true

    # Preserve the index file from the original .git
    temp_index=".git-wt-temp-index-$$"
    cp .git/index "$temp_index" 2>/dev/null || true

    # Move all working files to temporary directory
    temp_work=".git-wt-temp-work-$$"
    mkdir "$temp_work"
    echo "Preserving working files..."
    find . -maxdepth 1 ! -name . ! -name .. ! -name .git ! -name "$temp_bare" ! -name "$temp_work" ! -name "$temp_index" \
      -exec mv {} "$temp_work/" \; 2>/dev/null || true

    # Preserve stash refs if they exist (git clone --bare doesn't copy them)
    temp_stash_dir=""
    if [ -f .git/refs/stash ]; then
      temp_stash_dir=".git-wt-temp-stash-$$"
      mkdir -p "$temp_stash_dir"
      # Copy stash ref
      cp .git/refs/stash "$temp_stash_dir/stash"
      # Copy stash reflog (it's a file, not a directory)
      if [ -f .git/logs/refs/stash ]; then
        mkdir -p "$temp_stash_dir/logs"
        cp .git/logs/refs/stash "$temp_stash_dir/logs/stash"
      fi
    fi

    # Replace .git with bare repository
    echo "Reorganizing repository structure..."
    rm -rf .git
    mv "$temp_bare" .git

    # Restore stash refs if they were preserved
    if [ -n "$temp_stash_dir" ] && [ -d "$temp_stash_dir" ]; then
      if [ -f "$temp_stash_dir/stash" ]; then
        cp "$temp_stash_dir/stash" .git/refs/stash
      fi
      if [ -f "$temp_stash_dir/logs/stash" ]; then
        mkdir -p .git/logs/refs
        cp "$temp_stash_dir/logs/stash" .git/logs/refs/stash
      fi
      rm -rf "$temp_stash_dir"
    fi

    # Configure bare repo properly
    git config --bool core.bare true

    # Set up fetch refspec if remote exists
    if git config remote.origin.url >/dev/null 2>&1; then
      git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    fi

    # Create worktree for current branch from preserved files
    echo "Creating worktree for '$current_branch' branch..."
    # Create parent directories if branch name contains slashes (e.g., feature/foo)
    mkdir -p "$(dirname "$current_branch")"
    mv "$temp_work" "$current_branch"

    # Register as worktree manually (git worktree add doesn't work well with existing files)
    # Convert slashes to dashes for worktree metadata directory name
    # (git encodes slashes when creating worktree metadata)
    worktree_name=$(echo "$current_branch" | tr '/' '-')
    mkdir -p .git/worktrees/"$worktree_name"
    echo "gitdir: $repo_root/.git/worktrees/$worktree_name" > "$current_branch/.git"
    echo "$repo_root/$current_branch" > .git/worktrees/"$worktree_name"/gitdir
    echo "ref: refs/heads/$current_branch" > .git/worktrees/"$worktree_name"/HEAD

    # Copy common git files to worktree admin directory
    touch .git/worktrees/"$worktree_name"/commondir
    echo "../.." > .git/worktrees/"$worktree_name"/commondir

    # Restore the index file to preserve staging area state
    if [ -f "$temp_index" ]; then
      mv "$temp_index" .git/worktrees/"$worktree_name"/index
    fi

    # Detect primary branch - check for main/master explicitly
    primary_branch=""
    if git rev-parse --verify refs/heads/main >/dev/null 2>&1; then
      primary_branch="main"
    elif git rev-parse --verify refs/heads/master >/dev/null 2>&1; then
      primary_branch="master"
    fi

    # Create worktree for primary branch (if different from current)
    if [ -n "$primary_branch" ] && [ "$primary_branch" != "$current_branch" ]; then
      echo "Creating worktree for '$primary_branch' branch..."
      git worktree add "$primary_branch" "$primary_branch" 2>&1 | grep -v "^Preparing worktree" || true
    fi

    # Clear trap
    trap - ERR

    # Success message
    echo ""
    echo "Successfully converted to worktree structure!"
    echo ""
    echo "Repository structure:"
    echo "  .git/                    (bare repository)"
    echo "  $current_branch/         (worktree - your current branch)"
    if [ -n "$primary_branch" ] && [ "$primary_branch" != "$current_branch" ]; then
      echo "  $primary_branch/         (worktree - primary branch)"
    fi
    echo ""
    if [ "$has_changes" = true ]; then
      echo "Your uncommitted changes have been preserved in $current_branch/"
      echo ""
    fi
    echo "Worktree list:"
    git worktree list
    ;;

  setup)
    shift

    # Parse flags
    config_only=false
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --config-only)
          config_only=true
          shift
          ;;
        *)
          echo "Unknown option: $1"
          echo "Usage: git-wt setup [--config-only]"
          exit 1
          ;;
      esac
    done

    # Check for git (required)
    if ! command -v git &> /dev/null; then
      echo "Error: git is not installed"
      echo "Please install git first: https://git-scm.com/downloads"
      exit 1
    fi

    # If --config-only, just set up git config and exit
    if [ "$config_only" = true ]; then
      setup_git_config
      echo ""
      echo "Setup complete! The git alias 'git wt' is now configured."
      exit 0
    fi

    # Detect script location
    SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    # Detect if installed via Homebrew
    is_homebrew=false
    if echo "$SCRIPT_PATH" | grep -qE "(homebrew|Homebrew|Cellar|/usr/local/bin|/opt/homebrew)"; then
      is_homebrew=true
    fi

    # If installed via Homebrew, just configure git
    if [ "$is_homebrew" = true ]; then
      echo "Detected Homebrew installation at: $SCRIPT_PATH"
      echo ""
      echo "git-wt is already installed via Homebrew - no file installation needed."
      echo "Configuring git alias..."
      echo ""
      setup_git_config
      echo ""
      echo "Setup complete! Try it out:"
      echo "  git wt clone <repo-url>"
      echo ""
      echo "Reorganize an existing repository with worktrees:"
      echo "  git wt init"
      exit 0
    fi

    # Determine install location for manual installation
    if [ -w /usr/local/bin ]; then
      INSTALL_DIR="/usr/local/bin"
    else
      INSTALL_DIR="$HOME/bin"
      mkdir -p "$INSTALL_DIR"

      # Check if ~/bin is in PATH, warn if not
      if [[ ":$PATH:" != *":$HOME/bin:"* ]]; then
        echo ""
        echo "Note: $HOME/bin is not in your PATH"
        echo "Add this to your ~/.bashrc or ~/.zshrc:"
        echo '  export PATH="$HOME/bin:$PATH"'
        echo ""
      fi
    fi

    # Check if git-wt already exists at install location
    if [ -f "$INSTALL_DIR/git-wt" ] && [ "$SCRIPT_PATH" != "$INSTALL_DIR/git-wt" ]; then
      echo "git-wt is already installed at $INSTALL_DIR/git-wt"
      read -p "Do you want to overwrite it? (y/N) " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Setup cancelled."
        exit 0
      fi
    fi

    # Copy script
    cp "$SCRIPT_PATH" "$INSTALL_DIR/git-wt"
    chmod +x "$INSTALL_DIR/git-wt"

    echo "✓ git-wt installed to $INSTALL_DIR/git-wt"
    echo ""

    # Set up git alias
    setup_git_config

    # Check for git-crypt (optional)
    echo ""
    if command -v git-crypt &> /dev/null; then
      echo "✓ git-crypt found (optional git-crypt features will work)"
    else
      echo "Note: git-crypt not found (optional - only needed for encrypted repos)"
    fi

    echo ""
    echo "Setup complete! Try it out:"
    echo "  git wt clone <repo-url>"
    echo ""
    echo "Reorganize an existing repository with worktrees:"
    echo "  git wt init"
    ;;

  install-hooks)
    shift

    # No arguments - show available hooks
    if [ $# -eq 0 ]; then
      show_available_hooks
      exit 0
    fi

    # Install specified hook type
    hook_type="$1"
    install_hooks "$hook_type"
    ;;

  --help|-h|help)
    show_help
    ;;

  *)
    # Pass through to normal git worktree
    git worktree "$@"
    ;;
esac
