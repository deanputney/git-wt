#!/bin/bash

# Helper function to find the common git directory where hooks are stored
find_git_common_dir() {
  # In worktrees, --git-common-dir gives the shared .git directory
  # In normal repos, it returns the same as --git-dir
  local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
  echo "$git_common_dir"
}

# Helper function to run a hook if it exists
run_hook() {
  local hook_name="$1"
  shift
  local git_common_dir=$(find_git_common_dir)

  if [ -z "$git_common_dir" ]; then
    return 0
  fi

  local hook_path="$git_common_dir/hooks/$hook_name"

  if [ -x "$hook_path" ]; then
    "$hook_path" "$@"
    return $?
  fi

  return 0
}

case "$1" in
  a|add)
    shift

    # Run pre-worktree-add hook with the arguments that will be passed to git worktree add
    run_hook "git-wt-pre-worktree-add" "$@"
    hook_status=$?

    if [ $hook_status -ne 0 ]; then
      echo "git-wt: pre-worktree-add hook failed with exit code $hook_status" >&2
      exit $hook_status
    fi

    # Extract the worktree path (first argument)
    worktree_path="$1"

    # Create the worktree
    git worktree add "$@"
    add_status=$?

    if [ $add_status -ne 0 ]; then
      echo "git-wt: git worktree add failed with exit code $add_status" >&2
      exit $add_status
    fi

    # Run post-worktree-add hook with the worktree path and all original arguments
    run_hook "git-wt-post-worktree-add" "$worktree_path" "$@"
    hook_status=$?

    if [ $hook_status -ne 0 ]; then
      echo "git-wt: post-worktree-add hook failed with exit code $hook_status" >&2
      echo "git-wt: worktree was created but post-processing failed" >&2
      exit $hook_status
    fi
    ;;

  rm|remove)
    shift
    git worktree remove "$@"
    ;;

  ls|list)
    shift
    git worktree list
    ;;

  cl|clone)
    shift
    repo_url="$1"
    folder_name="${2:-$(basename "$repo_url" .git)}"

    if [ -z "$repo_url" ]; then
      echo "Usage: git-wt clone <repository-url> [folder-name]"
      exit 1
    fi

    # Create the folder and clone bare
    mkdir -p "$folder_name"
    git clone --bare "$repo_url" "$folder_name/.git"

    # Set up fetch refspec for remote tracking
    git -C "$folder_name/.git" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

    # Determine the primary branch from HEAD
    primary_branch=$(git -C "$folder_name/.git" symbolic-ref --short HEAD 2>/dev/null)

    # Fallback to main or master
    if [ -z "$primary_branch" ]; then
      if git -C "$folder_name/.git" rev-parse --verify refs/heads/main >/dev/null 2>&1; then
        primary_branch="main"
      elif git -C "$folder_name/.git" rev-parse --verify refs/heads/master >/dev/null 2>&1; then
        primary_branch="master"
      else
        echo "Error: Could not determine primary branch"
        exit 1
      fi
    fi

    # Add worktree for primary branch
    git -C "$folder_name/.git" worktree add "../$primary_branch" "$primary_branch"

    echo "Cloned $repo_url into $folder_name/"
    echo "Primary branch '$primary_branch' checked out at $folder_name/$primary_branch/"
    ;;

  *)
    # Pass through to normal git worktree
    git worktree "$@"
    ;;
esac
